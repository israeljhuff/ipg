###############################################################################
# scripting language name TBD
# grammar definition
# Author: Israel Huff
# https://github.com/israeljhuff/???
###############################################################################

# TODO: class support

program                       : wscm* (flow_control | function | scope | statement)* wscm*;

ws                    discard : [ \n\r\t];
comment               discard : "#" [^\r\n]*;
wscm                  discard : ws | comment;

flow_control          mergeup : wscm* (if_elif_else_block | loop_block) wscm*;

if_elif_else_block    mergeup : if_scope (wscm* elif_scope)* (wscm* else_scope)?;
if_scope                      : "if" wscm* "(" wscm* expr_non_assign wscm* ")" wscm* scope;
elif_scope                    : "elif" wscm* "(" wscm* expr_non_assign wscm* ")" wscm* scope;
else_scope                    : "else" wscm* scope;

loop_block                    : loop_keyword ((wscm+ "post") | wscm*)
                                (
                                 loop_open
                                 loop_init? loop_sep loop_check? loop_sep loop_update?
                                 loop_close
                                )?
                                scope;
loop_keyword          discard : "loop";
loop_open             discard : wscm* "(" wscm*;
loop_close            discard : wscm* ")" wscm*;
loop_sep              discard : wscm* ";" wscm*;
loop_init                     : expr_declare_vars | expr_assign_multiple;
loop_check                    : expr_non_assign;
loop_update                   : expr_assign;

scope                         : wscm* scope_open wscm* (flow_control | scope | statement)* wscm* scope_close wscm*;
scope_open            discard : "{";
scope_close           discard : "}";

statement                     : wscm* expression wscm* statement_term wscm*;
statement_term        discard : ";";

# function ####################################################################
function                      : wscm* (type | expr_decl_vector_type | expr_decl_map_type | identifier) wscm+
                                identifier wscm*
                                func_params_open  wscm*
                                func_param (wscm* func_params_sep wscm* func_param)*  wscm*
                                func_params_close  wscm*
                                scope_open wscm*
                                (flow_control | scope | statement)* wscm*
                                scope_close wscm*;
func_param                    : (type | expr_decl_vector_type | expr_decl_map_type | identifier) wscm+ identifier;
func_params_sep       discard : ",";
func_params_open      discard : "(";
func_params_close     discard : ")";

# expressions #################################################################
expression                    : expr_flow_control | expr_declare_vars | expr_assign | expr_non_assign;

expr_declare_vars             : (type | expr_decl_vector_type | expr_decl_map_type | identifier)
                                wscm+ expr_decl_vars_part (wscm* expr_decl_sep wscm* expr_decl_vars_part)*;
expr_decl_vars_part           : identifier wscm* op_decl_assign wscm* expr_non_assign;

expr_decl_vector_type         : "vector"
                                wscm* expr_decl_open wscm*
                                (type | expr_decl_vector_type | expr_decl_map_type | identifier)
                                wscm* expr_decl_close;

expr_decl_map_type            : "map"
                                wscm* expr_decl_open wscm*
                                (type | identifier) wscm* expr_decl_sep wscm*
                                (type | expr_decl_vector_type | expr_decl_map_type | identifier)
                                wscm* expr_decl_close;

expr_decl_sep         discard : ",";
expr_decl_open        discard : "<";
expr_decl_close       discard : ">";

expr_assign                   : identifier wscm* op_assign wscm* expr_non_assign;

expr_assign_multiple          : expr_assign_mult_part (wscm* expr_assign_mult_sep wscm* expr_assign_mult_part)*;
expr_assign_mult_part         : identifier wscm* op_assign_simple wscm* expr_non_assign;
expr_assign_mult_sep  discard : ",";

expr_non_assign               : expr_non_assign_part operand (wscm* op_binary wscm* expr_non_assign_part operand)*;
expr_non_assign_part          : typecast? wscm* op_unary? wscm* typecast? wscm*;

expr_flow_control             : "break" wscm* expr_non_assign? | "continue" | "return" wscm* expr_non_assign?;

type                          : "sint8"  | "uint8"  |
                                "sint16" | "uint16" |
                                "sint32" | "uint32" |
                                "sint64" | "uint64" |
                                "fp32"   | "fp64"   |
                                "bool"   |
                                "string";

typecast                      : typecast_open wscm* (type | identifier) wscm* typecast_close;
typecast_open         discard : "(";
typecast_close        discard : ")";

operand                       : identifier | literal | group | regex;

group                         : group_open expr_non_assign group_close;
group_open            discard : "(" wscm*;
group_close           discard : wscm* ")";

# operators ###################################################################
op_decl_assign                : "=";
op_unary                      : op_arithmetic_unary | op_logical_unary;
op_binary                     : op_arithmetic_binary | op_logical_binary | op_compare;
op_arithmetic_unary           : "-" | "~";
op_arithmetic_binary          : "+" | "-" | "*" | "/" | "%" | "&" | "|" | "^" | "<<" | ">>";
op_assign                     : "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" | "=~" | "!~" | op_assign_simple;
op_assign_simple              : "=";
op_logical_unary              : "!";
op_logical_binary             : "&&" | "||";
op_compare                    : "==" | "!=" | "<=" | ">=" | "<" | ">";

identifier             inline : [A-Za-z][0-9A-Za-z_]*;
literal                       : float | integer | string | literal_vector | literal_map;

# simple Perl-like regex syntax ###############################################
regex                         : re_open_close re_alternates re_open_close;
re_open_close         discard : "/";
re_alternates                 : re_alt (re_alt_sep re_alt)*;
re_alt_sep            discard : "|";
re_alt                        : re_part+;
re_part                       : (re_char | ch_class | re_group) re_quantifier?;
re_char                       : [\u0020-\U0010ffff!/!\\] | esc_re_char;
re_group                      : re_group_open re_alternates re_group_close;
re_group_open         discard : "(";
re_group_close        discard : ")";
re_quantifier                 : "*" | "+" | "?";

# character class for regular expressions
ch_class                      : ch_class_open ch_class_neg? ch_class_range* ch_class_close;
ch_class_open         discard : "[";
ch_class_neg                  : "^";
ch_class_close        discard : "]";
ch_class_range                : ch_class_range_neg? ch_class_char (ch_class_range_sep ch_class_char)?;
ch_class_range_neg            : "!";
ch_class_range_sep    discard : "-";
ch_class_char          inline : [\u0020-\U0010ffff!\\!\]] | esc_ch_class_char;

# double-quoted string ########################################################
string                        : string_quote string_chars string_quote;
string_quote          discard : "\"";
string_chars           inline : string_char*;
string_char            inline : [\u0020-\U0010ffff!"!\\] | esc_string_char;

# escape and unicode characters ###############################################
esc_ch_class_char      inline : "\\" ([\!\-\[\\\]\^abfnrtv] | unicode);
esc_re_char            inline : "\\" ([$()*+./?\[\\\]\^abfnrtv|] | unicode);
esc_string_char        inline : "\\" (["\\abfnrtv] | unicode);
unicode                inline : "u" hex hex hex hex | "U00" hex hex hex hex hex hex;
hex                    inline : [0-9A-Fa-f];

# numbers #####################################################################
integer                inline : [+\-]?[1-9][0-9]*;

# approximating C float syntax
float                  inline : [+\-]?[0-9]+ exponent?
                                |
                                [+\-]?[0-9]+([.][0-9]*) exponent?
                                |
                                [+\-]?[0-9]*([.][0-9]+) exponent?;
exponent               inline : [eE][+\-]?[0-9]+;

# literal vector ##############################################################
literal_vector                : lit_vec_open wscm*
                                (expr_non_assign wscm* lit_vec_sep wscm*)*
                                lit_vec_close;
lit_vec_open          discard : "[";
lit_vec_close         discard : "]";
lit_vec_sep           discard : ",";

# literal map #################################################################
literal_map                   : lit_map_open wscm*
                                (lit_map_key_value wscm* lit_map_sep_elem wscm*)*
                                lit_map_close;
lit_map_key_value             : expr_non_assign wscm* lit_map_sep_kv wscm* expr_non_assign;
lit_map_open          discard : "{";
lit_map_close         discard : "}";
lit_map_sep_elem      discard : ",";
lit_map_sep_kv        discard : ":";
